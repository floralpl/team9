import type { TSchema } from '../schema/index';
import { type TNever } from '../never/index';
import { type TOptional } from '../optional/index';
import type { TReadonly } from '../readonly/index';
import { TIntersect, IntersectOptions } from './intersect-type';
<<<<<<< HEAD
type TIsIntersectOptional<T extends TSchema[]> = (T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? L extends TOptional<TSchema> ? TIsIntersectOptional<R> : false : true);
type TRemoveOptionalFromType<T extends TSchema> = (T extends TReadonly<infer S extends TSchema> ? TReadonly<TRemoveOptionalFromType<S>> : T extends TOptional<infer S extends TSchema> ? TRemoveOptionalFromType<S> : T);
type TRemoveOptionalFromRest<T extends TSchema[], Acc extends TSchema[] = []> = (T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? L extends TOptional<infer S extends TSchema> ? TRemoveOptionalFromRest<R, [...Acc, TRemoveOptionalFromType<S>]> : TRemoveOptionalFromRest<R, [...Acc, L]> : Acc);
type TResolveIntersect<T extends TSchema[]> = (TIsIntersectOptional<T> extends true ? TOptional<TIntersect<TRemoveOptionalFromRest<T>>> : TIntersect<TRemoveOptionalFromRest<T>>);
export type TIntersectEvaluated<T extends TSchema[]> = (T extends [] ? TNever : T extends [TSchema] ? T[0] : TResolveIntersect<T>);
/** `[Json]` Creates an evaluated Intersect type */
export declare function IntersectEvaluated<T extends TSchema[], R = TIntersectEvaluated<T>>(T: [...T], options?: IntersectOptions): R;
=======
type TIsIntersectOptional<Types extends TSchema[]> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? Left extends TOptional<TSchema> ? TIsIntersectOptional<Right> : false : true);
type TRemoveOptionalFromType<Type extends TSchema> = (Type extends TReadonly<infer Type extends TSchema> ? TReadonly<TRemoveOptionalFromType<Type>> : Type extends TOptional<infer Type extends TSchema> ? TRemoveOptionalFromType<Type> : Type);
type TRemoveOptionalFromRest<Types extends TSchema[], Result extends TSchema[] = []> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? Left extends TOptional<infer Type extends TSchema> ? TRemoveOptionalFromRest<Right, [...Result, TRemoveOptionalFromType<Type>]> : TRemoveOptionalFromRest<Right, [...Result, Left]> : Result);
type TResolveIntersect<Types extends TSchema[]> = (TIsIntersectOptional<Types> extends true ? TOptional<TIntersect<TRemoveOptionalFromRest<Types>>> : TIntersect<TRemoveOptionalFromRest<Types>>);
export type TIntersectEvaluated<Types extends TSchema[]> = (Types extends [TSchema] ? Types[0] : Types extends [] ? TNever : TResolveIntersect<Types>);
/** `[Json]` Creates an evaluated Intersect type */
export declare function IntersectEvaluated<Types extends TSchema[], Result extends TSchema = TIntersectEvaluated<Types>>(types: [...Types], options?: IntersectOptions): Result;
>>>>>>> dd36f794aec55329dba52bd59bdd29e0d232b50c
export {};
