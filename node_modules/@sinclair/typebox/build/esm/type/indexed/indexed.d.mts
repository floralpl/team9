import { type TSchema, SchemaOptions } from '../schema/index.mjs';
<<<<<<< HEAD
import { type TObject, type TProperties } from '../object/index.mjs';
import { type Assert } from '../helpers/index.mjs';
import { type TNever } from '../never/index.mjs';
import { type TRecursive } from '../recursive/index.mjs';
import { type TIntersect } from '../intersect/index.mjs';
import { TMappedResult, type TMappedKey } from '../mapped/index.mjs';
import { type TUnion } from '../union/index.mjs';
import { type TTuple } from '../tuple/index.mjs';
import { type TArray } from '../array/index.mjs';
=======
import { type Assert } from '../helpers/index.mjs';
import { type TComputed } from '../computed/index.mjs';
import { type TNever } from '../never/index.mjs';
import { type TArray } from '../array/index.mjs';
import { type TIntersect } from '../intersect/index.mjs';
import { type TMappedResult, type TMappedKey } from '../mapped/index.mjs';
import { type TObject, type TProperties } from '../object/index.mjs';
import { type TUnion } from '../union/index.mjs';
import { type TRecursive } from '../recursive/index.mjs';
import { type TRef } from '../ref/index.mjs';
import { type TTuple } from '../tuple/index.mjs';
>>>>>>> dd36f794aec55329dba52bd59bdd29e0d232b50c
import { type TIntersectEvaluated } from '../intersect/index.mjs';
import { type TUnionEvaluated } from '../union/index.mjs';
import { type TIndexPropertyKeys } from './indexed-property-keys.mjs';
import { type TIndexFromMappedKey } from './indexed-from-mapped-key.mjs';
import { type TIndexFromMappedResult } from './indexed-from-mapped-result.mjs';
<<<<<<< HEAD
type TFromRest<T extends TSchema[], K extends PropertyKey, Acc extends TSchema[] = []> = (T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? TFromRest<R, K, [...Acc, Assert<TIndexFromPropertyKey<L, K>, TSchema>]> : Acc);
type TFromIntersectRest<T extends TSchema[], Acc extends TSchema[] = []> = (T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? L extends TNever ? TFromIntersectRest<R, [...Acc]> : TFromIntersectRest<R, [...Acc, L]> : Acc);
type TFromIntersect<T extends TSchema[], K extends PropertyKey> = (TIntersectEvaluated<TFromIntersectRest<TFromRest<T, K>>>);
type TFromUnionRest<T extends TSchema[], Acc extends TSchema[] = []> = T extends [infer L extends TSchema, ...infer R extends TSchema[]] ? L extends TNever ? [] : TFromUnionRest<R, [L, ...Acc]> : Acc;
type TFromUnion<T extends TSchema[], K extends PropertyKey> = (TUnionEvaluated<TFromUnionRest<TFromRest<T, K>>>);
type TFromTuple<T extends TSchema[], K extends PropertyKey> = (K extends keyof T ? T[K] : K extends '[number]' ? TUnionEvaluated<T> : TNever);
type TFromArray<T extends TSchema, K extends PropertyKey> = (K extends '[number]' ? T : TNever);
type AssertPropertyKey<T> = Assert<T, string | number>;
type TFromProperty<T extends TProperties, K extends PropertyKey> = (K extends keyof T ? T[K] : `${AssertPropertyKey<K>}` extends `${AssertPropertyKey<keyof T>}` ? T[AssertPropertyKey<K>] : TNever);
export type TIndexFromPropertyKey<T extends TSchema, K extends PropertyKey> = (T extends TRecursive<infer S> ? TIndexFromPropertyKey<S, K> : T extends TIntersect<infer S> ? TFromIntersect<S, K> : T extends TUnion<infer S> ? TFromUnion<S, K> : T extends TTuple<infer S> ? TFromTuple<S, K> : T extends TArray<infer S> ? TFromArray<S, K> : T extends TObject<infer S> ? TFromProperty<S, K> : TNever);
export declare function IndexFromPropertyKey<T extends TSchema, K extends PropertyKey>(T: T, K: K): TIndexFromPropertyKey<T, K>;
export type TIndexFromPropertyKeys<T extends TSchema, K extends PropertyKey[], Acc extends TSchema[] = []> = (K extends [infer L extends PropertyKey, ...infer R extends PropertyKey[]] ? TIndexFromPropertyKeys<T, R, [...Acc, Assert<TIndexFromPropertyKey<T, L>, TSchema>]> : Acc);
export declare function IndexFromPropertyKeys<T extends TSchema, K extends PropertyKey[]>(T: T, K: [...K]): TIndexFromPropertyKeys<T, K>;
type FromSchema<T extends TSchema, K extends PropertyKey[]> = (TUnionEvaluated<TIndexFromPropertyKeys<T, K>>);
declare function FromSchema<T extends TSchema, K extends PropertyKey[]>(T: T, K: [...K]): FromSchema<T, K>;
export type TIndex<T extends TSchema, K extends PropertyKey[]> = (FromSchema<T, K>);
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<T extends TSchema, K extends TMappedResult>(T: T, K: K, options?: SchemaOptions): TIndexFromMappedResult<T, K>;
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<T extends TSchema, K extends TMappedKey>(T: T, K: K, options?: SchemaOptions): TIndexFromMappedKey<T, K>;
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<T extends TSchema, K extends TSchema, I extends PropertyKey[] = TIndexPropertyKeys<K>>(T: T, K: K, options?: SchemaOptions): TIndex<T, I>;
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<T extends TSchema, K extends PropertyKey[]>(T: T, K: readonly [...K], options?: SchemaOptions): TIndex<T, K>;
=======
type TFromRest<Types extends TSchema[], Key extends PropertyKey, Result extends TSchema[] = []> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? TFromRest<Right, Key, [...Result, Assert<TIndexFromPropertyKey<Left, Key>, TSchema>]> : Result);
type TFromIntersectRest<Types extends TSchema[], Result extends TSchema[] = []> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? Left extends TNever ? TFromIntersectRest<Right, [...Result]> : TFromIntersectRest<Right, [...Result, Left]> : Result);
type TFromIntersect<Types extends TSchema[], Key extends PropertyKey> = (TIntersectEvaluated<TFromIntersectRest<TFromRest<Types, Key>>>);
type TFromUnionRest<Types extends TSchema[], Result extends TSchema[] = []> = Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? Left extends TNever ? [] : TFromUnionRest<Right, [Left, ...Result]> : Result;
type TFromUnion<Types extends TSchema[], Key extends PropertyKey> = (TUnionEvaluated<TFromUnionRest<TFromRest<Types, Key>>>);
type TFromTuple<Types extends TSchema[], Key extends PropertyKey> = (Key extends keyof Types ? Types[Key] : Key extends '[number]' ? TUnionEvaluated<Types> : TNever);
type TFromArray<Type extends TSchema, Key extends PropertyKey> = (Key extends '[number]' ? Type : TNever);
type AssertPropertyKey<T> = Assert<T, string | number>;
type TFromProperty<Properties extends TProperties, Key extends PropertyKey> = (Key extends keyof Properties ? Properties[Key] : `${AssertPropertyKey<Key>}` extends `${AssertPropertyKey<keyof Properties>}` ? Properties[AssertPropertyKey<Key>] : TNever);
export type TIndexFromPropertyKey<Type extends TSchema, Key extends PropertyKey> = (Type extends TRecursive<infer Type extends TSchema> ? TIndexFromPropertyKey<Type, Key> : Type extends TIntersect<infer Types extends TSchema[]> ? TFromIntersect<Types, Key> : Type extends TUnion<infer Types extends TSchema[]> ? TFromUnion<Types, Key> : Type extends TTuple<infer Types extends TSchema[]> ? TFromTuple<Types, Key> : Type extends TArray<infer Type extends TSchema> ? TFromArray<Type, Key> : Type extends TObject<infer Properties extends TProperties> ? TFromProperty<Properties, Key> : TNever);
export declare function IndexFromPropertyKey<Type extends TSchema, Key extends PropertyKey>(type: Type, propertyKey: Key): TIndexFromPropertyKey<Type, Key>;
export type TIndexFromPropertyKeys<Type extends TSchema, PropertyKeys extends PropertyKey[], Result extends TSchema[] = []> = (PropertyKeys extends [infer Left extends PropertyKey, ...infer Right extends PropertyKey[]] ? TIndexFromPropertyKeys<Type, Right, [...Result, Assert<TIndexFromPropertyKey<Type, Left>, TSchema>]> : Result);
export declare function IndexFromPropertyKeys<Type extends TSchema, PropertyKeys extends PropertyKey[]>(type: Type, propertyKeys: [...PropertyKeys]): TIndexFromPropertyKeys<Type, PropertyKeys>;
type FromSchema<Type extends TSchema, PropertyKeys extends PropertyKey[]> = (TUnionEvaluated<TIndexFromPropertyKeys<Type, PropertyKeys>>);
declare function FromSchema<Type extends TSchema, PropertyKeys extends PropertyKey[]>(type: Type, propertyKeys: [...PropertyKeys]): FromSchema<Type, PropertyKeys>;
export type TIndexFromComputed<Type extends TSchema, Key extends TSchema> = (TComputed<'Index', [Type, Key]>);
export declare function IndexFromComputed<Type extends TSchema, Key extends TSchema>(type: Type, key: Key): TIndexFromComputed<Type, Key>;
export type TIndex<Type extends TSchema, PropertyKeys extends PropertyKey[]> = (FromSchema<Type, PropertyKeys>);
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<Type extends TRef, Key extends TSchema>(type: Type, key: Key, options?: SchemaOptions): TIndexFromComputed<Type, Key>;
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<Type extends TSchema, Key extends TRef>(type: Type, key: Key, options?: SchemaOptions): TIndexFromComputed<Type, Key>;
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<Type extends TRef, Key extends TRef>(type: Type, key: Key, options?: SchemaOptions): TIndexFromComputed<Type, Key>;
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<Type extends TSchema, MappedResult extends TMappedResult>(type: Type, mappedResult: MappedResult, options?: SchemaOptions): TIndexFromMappedResult<Type, MappedResult>;
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<Type extends TSchema, MappedResult extends TMappedResult>(type: Type, mappedResult: MappedResult, options?: SchemaOptions): TIndexFromMappedResult<Type, MappedResult>;
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<Type extends TSchema, MappedKey extends TMappedKey>(type: Type, mappedKey: MappedKey, options?: SchemaOptions): TIndexFromMappedKey<Type, MappedKey>;
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<Type extends TSchema, Key extends TSchema, PropertyKeys extends PropertyKey[] = TIndexPropertyKeys<Key>>(T: Type, K: Key, options?: SchemaOptions): TIndex<Type, PropertyKeys>;
/** `[Json]` Returns an Indexed property type for the given keys */
export declare function Index<Type extends TSchema, PropertyKeys extends PropertyKey[]>(type: Type, propertyKeys: readonly [...PropertyKeys], options?: SchemaOptions): TIndex<Type, PropertyKeys>;
>>>>>>> dd36f794aec55329dba52bd59bdd29e0d232b50c
export {};
